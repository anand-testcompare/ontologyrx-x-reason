This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started
Install all dependecnies:

```bash
npm install
# or
yarn
# or
pnpm install
# or
bun install
```

Next create .env.local and add your OpenAI API key
```bash
OPENAI_API_KEY=<YOUR_KEY>
```

Run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Video Demo
[![X-Reason Demo](http://img.youtube.com/vi/GqnSI1DDJe4/0.jpg)](http://www.youtube.com/watch?v=GqnSI1DDJe4 "X-Reason: Dynamic AI Generated Software Flows with X-State!")

## State
This is not production ready!!! I will be releasing an alpha soon. Expect bugs and breaking changes!

## Explanation
This app demonstrates how AI can dynamically assemble software from a task list. A macro is used to generate a state machine in XState from the resulting task list generated by AI models. Individual states can be long-running and pause execution. This can facilitate user interaction (such as registration), waiting for callbacks from external systems, or performing async work such as persisting data or sending notifications.

This is just an early prototype, but one can imagine a future state where software can be composed from lists by non-technical users simply through describing the system in natural language. This approach also makes things like user registration, checkout, etc., a process which AI can perform adaptive problem solving based on the available information about the environment including the user and the available tasks it can perform. This reduces brittle if/then/else logic and allows AI to control the software experience. For example, the mock user registration process was assembled dynamically using this prompt:
```text
User
Using the following tools, create a user registration plan to register a user that will balance the user experience (ie the fewest steps and interactions) with business concerns like validating the user's age, upsell/cross-sell opportunities, etc.:
- Collect User Details (required collects information required for registrations)
- Age Confirmation (required for users who are under 16 in the US and Canada)
- Select Plan (required dependents on first collecting user details and age confirmation)
- TOS Acceptance (required must be performed before completing registration)
- Present Special Offers (optional special offers the user can select to save money)
- Select Partner Plugins (optionally select a plugin from the partner ecosystem)
- Persist User Details (required, saves the user's registration data including plan selection, TOS Acceptance, etc)
- Send Registration Event (notify downstream analytics systems a new user has been registered)

Let's take this step by step:
 First, determine which steps are required based on the user's location
Second, optimize your steps for user interaction and efficiency
Third, if the user is a frequent visitor, prioritize ways to help convert them to a paying customer. 

People who visit frequently are more likely to convert and put up with more steps in the registration process. New visitors or those who do not visit the site are more likely to bounce from the registration process.

You can only respond in JSON using the following template: [steps]

For example, if the user is not a resident of the US or Canada and not a request visitor:
["Collect User Details", "Select Plan", "TOS Acceptance", "Persist User Details", "Send Registration Event"]

This user is located in CA, USA, and has visited our site 165 times in the last 30 days.
```
The code then iterates over the returned list, assembling a map which is then passed to our macro to generate the state machine:
```TypeScript
taskList.forEach((state) => {
      map.set(state, steps.get(state));
    });

//setup the machine
const testMachine = machineMacro(map);

const machineExecution = interpret(withContext).onTransition((state) => {
      const type = machineExecution.machine.states[state.value as string]?.meta?.type;
      state.context.stack?.push(state.value as string);
      setState(map.get(state.value));
    });

    setMachine(machineExecution);

// start the machine
machineExecution.start(); 
```
And just like that you have an AI-generated user registration process customized to the user!

## Recent Updates (Feature Branch: add-support-for-convex-and-upgrade)

### Major Changes

1. **Multi-AI Provider Support**
   - Added support for multiple AI providers (OpenAI, Gemini, Convex) through a unified interface
   - Created `AIProviderSelector` component for runtime provider selection
   - Implemented provider-specific adapters with consistent API
   - Added streaming support for all providers

2. **Package Updates & Modernization**
   - Upgraded to Next.js 15.4.3 from 14.0.3
   - Updated XState from v4 to v5 with migration of state machine APIs
   - Updated all dependencies to latest versions
   - Migrated from npm to pnpm with lock file (maintaining npm compatibility)

3. **New Components & Features**
   - Added `StateMachineVisualizer` component for visual debugging of state machines
   - Implemented `ReasonDemoStream` component for streaming AI responses
   - Created Regie demo flow with complete user registration state machine
   - Added navigation component for better app navigation
   - Implemented AI request logging with request ID tracking

4. **Architecture Improvements**
   - Created centralized AI provider system in `/app/api/ai/`
   - Added streaming support for reasoning engine v2
   - Implemented proper error handling and retry mechanisms
   - Added comprehensive logging throughout the AI request pipeline

5. **UI/UX Enhancements**
   - Migrated from Blueprint.js to shadcn/ui components
   - Added Tailwind CSS for styling
   - Implemented dark mode support
   - Created consistent UI component library

6. **Configuration & Build**
   - Added support for environment-specific AI provider configuration
   - Updated Jest configuration for v29 compatibility
   - Added proper TypeScript configuration for new dependencies
   - Configured PostCSS and Tailwind

### Technical Details

- **AI Provider Integration**: The new AI system supports OpenAI, Google Gemini, and Convex through a unified interface, allowing seamless switching between providers
- **Streaming Architecture**: Implemented async generators for streaming responses, improving perceived performance for long-running AI operations
- **State Machine Updates**: Migrated to XState v5 syntax while maintaining backward compatibility through careful API updates
- **Component Library**: Replaced Blueprint.js with shadcn/ui for better customization and smaller bundle size

### Breaking Changes

- XState v4 APIs are no longer supported - all state machines must use v5 syntax
- Blueprint.js components have been removed - use shadcn/ui equivalents
- OpenAI model updated from GPT-4 to o4-mini by default

### Known Issues

- Several TODO items remain in the codebase for future implementation
- Some unused solution management functions in ReasonDemo component (cleanup in progress)
- Mixed package manager usage (npm/pnpm) - prefer npm for consistency

